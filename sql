פקודת SELECT 

מבנה הפקודה:
Select [distinct] column_name [*,column_name..]
From table_name
[where condition]
[group by column_name]
[having condition]
[order by column_name]



שימוש:
משפט select  מאפשר לקבל חתכי מידע שונים מתוך הטבלאות שבמאגר הנתונים.
ניתן לשלב במשפט חלקים שונים בהם נדון במהלך הפרק.

בחירת עמודות מטבלה
אפשר לבחור עמודות מסוימות מתוך בסיס הנתונים ע"י עריכת רשימה של העמודות הרצויות , ערכי העמודות יוחזרו לפי סדר הופעתן ברשימה כאשר באופן אוטומטי שמות העמודות יהוו כותרות עבור התוצאות המוחזרות.

דוגמה:
בסיס נתונים:Northwind.
בחירת השמות הפרטיים של כל העובדים שבטבלת Employees.

Select FirstName 
From Employees
דוגמה:
בסיס נתונים:Northwind.
בחירת מספר עובד ,שם פרטי ושם משפחה של כל העובדים שבטבלת Employees

Select EmployeeID,FirstName, LastName 
From Employees

*בחירת כל השדות תתבצע ע"י שימוש באופרטור * (כוכבית).

דוגמה:
בסיס נתונים:Northwind.
בחירת כל הפרטים  של  כל העובדים שבטבלת Employees

Select *
From Employees
נתינת שמות חלופיים לעמודות - Alias 
כפי שציינו קודם, שמות העמודות בתוצאה נקבעים באופן אוטומטי ע"פ שמות השדות בבסיס הנתונים. במידה ואנו רוצים להחליף שמות אלו לקריאים יותר בתוצאה המתקבלת  יש להשתמש בכינויים לעמודות באחד האופנים הבאים:
1. כאשר השם החדש מכיל מילה אחת - נציינה פשוט אחרי שם העמודה.
     דוגמה:
Select FirstName Name 
From Employees 
2. כאשר השם מכיל יותר ממילה אחת - נציין את השם החדש בין גרשיים.
    דוגמה:
Select FirstName " First name" 
From Employees 

*עבור שני האופנים ניתן לציין לפני השם החדש את המילה as עבור קריאות השאילתה.
דוגמה:
Select FirstName as " First name" ,LastName as "last" 
From Employees 

שירשור מספר שדות וטקסט חופשי תחת עמודה אחת בתוצאה

ניתן לשרשר שדות לשדות נוספים ולטקסט חופשי ע"י שימוש באופרטור + בין המילים. במידה ונשתמש בסימן זה העמודה לא תקבל שם ולכן נצטרך להגדיר עבורה שם חלופי (alias).

דוגמה:
בסיס נתונים:Northwind.
הצגת פרטי העובדים שבטבלת Employees באופן הבא:
תחת עמודה בשם name יופיעו שמו הפרטי ושם משפחתו של העובד ובעמודה נפרדת יופיע מספרו של העובד.

Select FirstName+"  "+ LastName as Name, EmployeeID 
From Employees


שימוש בפעולות אריתמטיות בעמודות התוצאה

ניתן לשלב פעולות חשבוניות על הערכים המוחזרים וביניהם.
הפעולות החשבוניות הן:
•	  + -   חיבור
•	  -  -   חיסור
•	  * -   כפל 
•	  / -    חילוק
•	  -Modulo  -% שארית כתוצאה מפעולת חילוק

דוגמה:
בסיס נתונים:Northwind.
בחירת שמות המוצרים,מחירם הרגיל (כפי שהוא  מוגדר בבסיס הנתונים) ומחירם לאחר תוספת של 18% (המוצרים מטבלת products).

select ProductName, UnitPrice, UnitPrice*1.18  
from products


*פעולות כפל וחילוק קודמות כמובן גם כאן לחיבור וחיסור , אלא אם השתמשנו בסוגריים.

דוגמה:
בסיס נתונים:Northwind.
הצגת שמות המוצרים ומחיריהם לאחר 10% הנחה.

Select ProductName, UnitPrice*0.9
From products 



פתרון בעיית כפילות של רשומות חוזרות

ניתן למנוע חזרה של רשומות זהות בתוצאה ע" שימוש במילה distinct.
המחשת צורך:
נניח והיינו רוצים לקבל את שמות וכתובות של כל הלקוחות שבצעו הזמנה של מוצר כלשהו, כדי לשלוח להם פרוספקט פרסומת. יכול להיווצר כמובן מצב שנקבל פעמיים את אותו השם, שכן אותו לקוח ביצע שתי הזמנות שונות, אך כמובן שאין אנו מעונינים לשלוח לו שני מכתבים ועל כן נרצה לקבל שם כל לקוח פעם אחת בלבד.

דוגמה:
בסיס נתונים:Northwind.
בחירת ה-id  של כל הלקוחות שביצעו הזמנה כלשהי.
Select distinct CustomerID 
From Products

 
שימוש ב-where

ניתן לבצע סינון של הרשומות החוזרות ע"י הוספת הפסוקית where למשפט ה-select .
לאחר המילה where יופיע תנאי אחד או מספר תנאים אשר יגבילו את הרשומות החוזרות .
התנאים יכילו לפחות אחד  מהאופרטורים הבאים:

אופרטורי השוואה:
=
>
<
=>
=<
<>
=!
<!
>!

אופרטורי טווח:
Between ,Not Between

אופרטורי רשימה: 
In,not in

אופרטורים להשוואת מחרוזות:
Like,not like


אופרטור הבודק ערכי null:
Is null, is not null

אופרטורים לוגיים לשילוב תנאים:
Or
And

אופרטור השלילה:
Not


 
שימוש באופרטורי השוואה

דוגמה:
בסיס נתונים:Northwind.
בחירת כל הפרטים  של  כל העובדים שבטבלת Employees אשר גרים בעיר London.

Select *
From Employees
‘Where City='London

שים לב כי תאריכים  ומחרוזות אשר תבוצע  השוואה לערכיהם יכתבו בין גרש לגרש, בעוד השוואה למספרים לא תדרוש שילוב גרשיים.

דוגמה:
בסיס נתונים:Northwind.
בחירת שמות כל המוצרים מטבלת Products אשר מספר היחידות הקיים מהם במלאי אינו עולה על 10.
Select ProductName 
From Products
10=>Where UnitsInStock


שימוש באופרטורי טווח
שימוש באופרטורי טווח מאפשר לבדוק האם ערך בשדה נמצא בין טווח ערכים מסוים .

דוגמה :
בסיס נתונים:Northwind.
בחירת שמות כל המוצרים מטבלתProducts  אשר מספר היחידות הקיים מהם בין 10 
ל- 20.

Select ProductName 
From Products
Between 10 and 20  Where UnitsInStock 

שימוש באופרטורי רשימה 
שימוש באופרטור in  מאפשר לבצע השוואה לרשימת ערכים, כאשר די כי ערך אחד יתאים על מנת שרשומה תוחזר.
(היחס ביו ערכי הרשימה הוא של or).

דוגמה:
בסיס נתונים:Northwind.
בחירת כל הפרטים  של  כל העובדים שבטבלת Employees, אשר גרים בעיר London או  Seattle או Tacoma.
Select *
From Employees
)‘ Tacom’,‘Seattle ’ ,‘Where City in ('London

שימוש באופרטורים להשוואת מחרוזות
אופרטורים אלו מאפשרים לבצע השוואה לחלקי מילים. שימושם נפוץ בשאילתות חיפוש כאשר אין אנו יודעים את אופן כתיבת הערך המלא שאנו מחפשים, כאשר פעולה זו מתאפשרת ע"י שימוש בתווי ההכללה הבאים:

Wildcard	משמעות
%      		אוסף כלשהו של תווים, יכול להכיל אפס תווים ויותר.
_       		מייצג תו בודד כלשהו ומתאים למחרוזת בעלת תו אחד בלבד.
[ ]      		מייצג תו אחד בלבד שבתוך טווח ערכים 
(לדוגמה [a-f] זהה ל- [abcdef]  )
[^]     		מייצג תו אחד בלבד שאינו בטווח הערכים 
(לדוגמה [^a-f] זהה ל-  [^abcdef])
 
הטבלה הבאה מציגה מספר דוגמהות לשימוש ב-  wildcardsבתוך תנאי החיפוש LIKE .

Expression		Returns
LIKE '[a-cdf]%' 		a, b, c, d, or f %
LIKE '[-acdf]%' 		-, a, c, d, or f %
LIKE 'abc_d%' 		abc_d%
LIKE 'abc[def]' 		abcd, abce, and abcf

דוגמה :
בסיס נתונים:Northwind.
בחירת כל הפרטים  של  כל העובדים שבטבלת Employees אשר  שמם הפרטי מתחיל באות  A.
Select *
From Employees
Where FirstName like 'A%'

דוגמה:
בסיס נתונים:Northwind.
בחירת כל הפרטים  של  כל העובדים שבטבלת Employees אשר המיקוד שלהם מתחיל במספר 9 ומסתיים במספר 2.
 * Select  
From Employees
where postalcode like '9%2'

ערכי- NULL   Null Values
הערך NULL מייצג ערך בלתי ידוע, ובשל היותו כזהANSI-standard SQL  אינו מספק ביטוי להשוואת ערך כלשהו אליו כלומר, הביטוי WHERE value = NULL  אינו קיים. במקום זה יש להשתמש במשפט ה-Where  בפעולה IS NULL או IS NOT NULL  .

דוגמה :
בסיס נתונים:Northwind.
בחירת כל העובדים שגרים באחד מהאזורים: WA,SP,BC או שלא מוגדר להם אזור מגורים.
Select CustomerId,CompanyName,Region
From Customers
Where region in('WA','SP','BC') or region IS NULL


במידה ומתקבל ערךnull  בתוצאה ניתן להמירו לערך אחר וזאת ע"י הפונקציה: isNull.
הפונקציה מקבלת 2 ארגומנטים:
1. ערך אשר תבדוק האם הוא null.
2. ערך שיושם במידה והערך של הארגומנט הראשון הוא null.

הדוגמה הבאה שולפת את העמודות  CustomerID, CompanyName, and Region מטבלת Customers עבור אותן רשומות הנמצאות בחד מהאזורים ‘WA’ or ‘SP’ or ‘BC’ או באזור בלתי ידוע.
 
USE Northwind
SELECT CustomerID, CompanyName, Region FROM 
Customers WHERE Region IN ('WA', 'SP', 'BC') OR 
Region IS NULL 
דוגמה:
בסיס נתונים:Northwind.
הדוגמה הבאה שולפת עת העמודות CompanyName, and Fax מטבלת     Suppliers  ומחליפה את מספרי הפקסים המוצגים כערכים בלתי ידועים (ערכיNULL ) במחרוזת Unknown.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
SELECT CompanyName, ISNULL(Fax,'Unknown') AS Fax FROM Suppliers

תוצאת הרצת הקוד

CompanyName                              	Fax
---------------------------		-------------------------- 
Exotic Liquids                           	Unknown
New Orleans Cajun Delights     Unknown
Grandma Kelly's Homestead     (313) 555-3349
:
(29 row(s) affected)



 
שימוש באופרטורים לוגיים לשילוב יותר מתנאי אחד
כאשר רוצים לשלב יותר מתנאי אחד ניתן להשתמש באופרטור or  או and. כשנשתמש באופרטור or  מספיק כי אחד מהתנאים יתקיים, בעוד שימוש באופרטור and מחייב את התקיימות כל התנאים.

טבלת :And

And	True	False	Null
True	True	False	Null
False	False	False	False
Null	Null	False	Null

טבלת Or:

Or	True	False	Null
True	True	True	True
False	True	False	Null
Null	True	Null	Null

שימוש באופרטור השלילה
שימוש באופרטור not  מאפשר לשלול כל תנאי המשתמש באחד האופרטורים שצוינו קודם.

טבלת :Not

Not	True	False	Null
	False	True	Null


סדר עדיפות האופרטורים
האופרטורים מצוינים מבעלי העדיפות הגבוהה לנמוכה בהנחה שאין סוגריים שכן אלו נותנים עדיפות גבוהה יותר.
1.	אופרטורי ההשוואה השונים (כולל אופרטורי רשימה, טווח וכד')
2.	Not
3.	And
4.	Or

 
דוגמה:
בסיס נתונים:Northwind.
בחירת שמות כל המוצרים מטבלת Products אשר מספר היחידות הקיים מהם קטן מ-  20 ומחירם גדול מ- 30.

select ProductName
from products
where UnitsInStock<20
and UnitPrice>30
מיון רשומות- Order By
ניתן למיין את הרשומות החוזרות ע"י צרוף הפסוקית  order by , המיון יכול לכלול מיון ראשי בלבד או שילוב של מיון ראשי עם מיונים משניים.

דוגמה:
בסיס נתונים:Northwind.
הצגת כל הקטגוריות שבטבלת Categories מסודרות לפי סדר אלפה-ביתי

select CategoryName
from Categories
order by CategoryName 

מיון בסדר יורד יתבצע ע"י הוספת המילה DESC לאחר שם עמודת המיון.
דוגמה:
select CategoryName
from Categories
order by CategoryName desc

במידה והשתמשנו ב-alias  לעמודה ניתן לבצע גם לפי שמו  מיון.

 
שילוב מידע ממספר טבלאות

קיימות שאילתות המאפשרות שילוב מידע ממספר טבלאות. שאילתות אלו נקראות שאילתותJoin , שכן הן שולפות מידע ממספר טבלאות תוך ניצול הקשרים הלוגים המוגדרים בין הטבלאות השונות.
פקודת join יוצרת מכפלה קרטזית בין הטבלאות - במקרה של שתי טבלאות כל שורה של טבלה אחת תצורף לכל אחת מהשורות של הטבלה השניה. מרחב השליפה יכלול N*M תוצאות כאשר N הינו מספר השורות בטבלה אחת ו- M הינו מספר השורות בטבלה השניה.
לרוב, לתוצאה המתקבלת ממכפלה קרטזית אין ערך של ממש בגלל עומס הנתונים הלא רלוונטיים, לפיכך יש לצרף תנאי where המתאר את הקשר בין שתי הטבלאות.

הקישורים בין הטבלאות נחלקים למספר סוגים והם:

•	Equijoin - שאילתה המבוססת על קשר של שוויון בין שתי טבלאות לפחות.
•	Non-equijoin- שאילתה המבוססת על קשר של אי שוויון בין שתי טבלאות לפחות.
•	Outer join - שאילתה המחזירה את כל הערכים מטבלה אחת ואת התואמים לה מהטבלה האחרת.
•	Self join – שאילתה המבוססת על קשר של טבלה עם עצמה. 

Equijoin
נניח כי היינו רוצים להציג את שמות המוצרים ואת שמות הקטגוריות אליהם הם שייכים. אנו יודעים כי בטבלת Products קיים שם המוצר ובטבלת categories מופיעים שמות הקטגוריות ועל כן היינו צריכים לפנות בו זמנית לשתי הטבלאות, אך כפי שציינו קודם, פניה לשתי הטבלאות ללא הוספת תנאי כלשהו תחזיר את כל הקומבינציות האפשריות, לכן במקרה של הרצת שאילתה מסוג זה נקבל כי כל מוצר שייך לכל אחת מהקטגוריות השונות.
ועל כן נבדוק על מה מבוסס הקשר בין הטבלאות ונגדירו בתת פסוקית : where.

דוגמה:
בסיס נתונים:Northwind.
הצגת שמות המוצרים מטבלת products  כאשר עבור כל מוצר מצוינת שם הקטגוריה שלו.

select CategoryName ,ProductName
from Categories,Products
Where Categories .CategoryId= Products. CategoryId 

כפי שניתן לראות בדוגמה, כאשר פונים לשדה המופיע בשתי הטבלאות יש לציין לפני הפניה לשדה את שם הטבלה אליה הוא שייך.
חשוב לציין כי גם אם לא מדובר בשדה משותף כדאי לציין את שם הטבלה שכן תהליך זה מקל על ה-server  בפעילותו ועל ידי כך משפר את ביצועיו.

 
שימוש ב-alias  לטבלאות
לכל טבלה במסד נתונים יש שם יחידני המוגדר בעת יצירתה.
ניתן לקבוע שם חלופי או כינוי - alias - לטבלה במקום שמה האמיתי, בדיוק כמו שביצענו עבור עמודות.
חשוב לזכור כי ה-Aliases   תקפים רק בפקודת ה- select אשר יצרה אותם והמוטיבציה להגדרתם היא בעיקר בשל שיקולי נוחות כתיבת השאילתה.
על מנת ליצורalias  לטבלה מה שנדרש הוא להוסיף את שם הקיצור לאחר ציון שם הטבלה בתת פסוקית From.

דוגמה המשלבתalias  לשמות הטבלאות:
בסיס הנתונים NorthWind

select c.CategoryName , p.ProductName
from Categories c,Products p
Where c .CategoryId= p. CategoryId 
שילוב יותר מ - 2 טבלאות
ניתן לשלב בשאילתת join  יותר מצמד טבלאות, אך במקרה זה כמובן נצטרך להרחיב את מספר התנאים בתת פסוקית where.

דוגמה:
בסיס נתונים:Northwind.
הצגת שמות המוצרים מטבלת products, כאשר עבור כל מוצר מצוין שם הקטגוריה שלו ושם החברה המספקת את המוצר .

select c.CategoryName , p.ProductName , s. CompanyName
from Categories c,Products p , Suppliers s 
Where c .CategoryId= p. CategoryId and
           s.SupplierID=p. SupplierID 

דרך נוספת לכתיבת Equijoin הינה ע"י השימוש במילה inner join בתת פסוקית from.

 
דוגמה:
בסיס נתונים:Northwind.
הדוגמה מציגה פרטי רשומות הזמנה אשר הוזמנו בהם 9 פריטים מאותו מוצר. עבור כל הזמנה מצוין שם המוצר, מחיר המוצר  ליחידה וכמות הפריטים. הנתונים ממוינים ע"פ מחיר עלות המוצר.

SELECT P.ProductName, O.UnitPrice, O.Quantity 
FROM  Products P INNER JOIN [Order Details] O 
		    ON O.ProductID = P.ProductID 
where Quantity = 9
ORDER BY O.UnitPrice
Non –Equijoin

שאילתה המכילה קשר בין שתי טבלאות אשר הוא אינו קשר של שוויון אלא גדול, קטן, בין לבין וכד'.

דוגמה :
בסיס הנתונים: Pubs
הצגת כל העובדים ששדה ה-level   שלהם בטווח של ה-level  של ג'וב :editor.

select e.emp_id ,e.job_lvl
from employee e,jobs j
where e.job_lvl between j.min_lvl and j.max_lvl 
and j.job_desc='editor'
Outer join 

שאילתה המחזירה את כל הנתונים מטבלה אחת ואת המשלימים לה מהטבלה האחרת.
במרחב התוצאה של שאילתת join רגילה מופיעות אך ורק רשימות המקיימות את התנאי. לדוגמה, אם הגדרנו שאילתת join בין מחלקות לעובדים ויש מחלקה שאין לה עובדים היא לא תופיע במרחב התוצאה, כלומר חלק מהרשומות ייעלמו.
בכדי להציג את כל הרשומות, כולל אלו שהוחסרו ב-join  הרגיל, נשתמש ב- outer join.
כיוון התנאי ב-outer join  קובע את הטבלה ממנה ילקחו כל הרשימות כולל אלו שאינן עונות על תנאי הקישור בין הטבלאות.

 
דוגמה :
בסיס נתונים:Northwind.
הצגת שמות כל הלקוחות מטבלתcustomers  ליד כל לקוח שיש לו הזמנה נציין את מספרה (יכול להיות לקוח שרשום במאגר אך ברגע זה אין לו הזמנה).

select c.customerid,o.orderid
from customers c left join orders o
on c.customerid=o.customerid

 (832 row(s) affected)


לעומת זאת, אילו היינו מריציםjoin   רגיל:
select c.customerid,o.orderid
from customers c inner join orders o
on c.customerid=o.customerid
 היינו מקבלים:
(830 row(s) affected)

וכנ"ל בהרצת right join, שכן לא יכולה להיות הזמנה שאינה משויכת ללקוח.

select c.customerid,o.orderid
from customers c right join orders o
on c.customerid=o.customerid

התוצאה:
830 row(s) affected)

 
Self join

לעיתים קיים צורך לבצע צירוף של רשימות מטבלה לרשימות מאותה טבלה - מהלך הנקרא reflexive join או self join.
SQL מאפשרת לפנות מספר פעמים אל אותה הטבלה במשפטselect  כאילו הפניה נעשתה למספר טבלאות שונות. היכולת להתיחס אל הטבלאות כאל שונות היא ע"י מתן  aliases שונים במשפט ה-from לטבלה עליה מתבצעת פעולת ה- self join (מעבר לכך פעולת הכתיבה רגילה).
לדוגמה :נניח כי היתה לנו טבלת עובדים אשר עבור כל עובד בין שאר הנתונים היה נשמר עבורו שמו ,מספר העובד שלו ומספר העובד של המנהל שלו , אילו היינו רוצים להדפיס את שמות העובדים ושמות מנהליהם היינו צריכים לפנות פעמיים לאותה טבלה פעם אחת עבור לקיחת שמות העובדים ופעם שניה עבור לקיחת שמות המנהלים שהם כמובן גם כן עובדים ולכן יופיעו באותה הטבלה – במקרה מסוג זה היינו משתמשים ב-self join.

דוגמה :
בסיס נתונים:Northwind.
הצגת שמות העובדים ושמות האנשים שהם מדווחים להם:

Select w.LastName+’  ‘+w.FirstName as "worker” ,
	r.LastName+’  ‘+r.FirstName as “Reports To”
from Employees w,Employees r
where w. ReportsTo=r.EmployeeId


שים לב, שעובדים שלא מדווחים לאף אחד - לא התקבלו שכן יצרנו self join  שאינה מבוססת על Outer join.
 
פונקציות הקבצה - Group Function

Group Function - הינן פונקציות המופעלות על מספר רשומות ומחזירות תשובה אחת משותפת עבור כל הרשומות שנבחרו. 
לדוגמה: פונקצית Max - פונקציה המקבלת מספר ערכים מרשומות שונות ומחזירה את הערך המקסימלי שביניהן.

סוגי Group Function:
•	Max - מחזירה את הערך הגבוה ביותר מבין הקבוצה.
•	Min - מחזירה את הערך הנמוך ביותר מבין הקבוצה.
•	Avg - מחזירה את ממוצע כל הערכים בקבוצה שהם לא NULL.
•	Count - מחזירה את מספר הפריטים בקבוצה.
•	Sum - סוכמת את מספר הפריטים בקבוצה.
•	 Stedv- מחזירה את סטית התקן של כל הערכים בביטוי.
•	 StedvP- מחזירה את סטית התקן עבור אוכלוסית כל הערכים בביטוי.
•	 Var- מחזירה את השונות של כל הערכים בביטוי
•	 VarP- מחזירה את השונות עבור אוכלוסית כל הערכים בביטוי.
 

דוגמה:
בסיס נתונים:Northwind.
הצגת ממוצע המחירים של המוצרים בטבלת products.

Select avg(UnitPrice)
From Products

דוגמה:
בסיס נתונים:Northwind.
הצגת מספר העובדים שגרים בעיר London .

Select count(*)
From Employees
Where city='London'

דוגמה:
בסיס נתונים:Northwind.
הצגת מספר הלקוחות שביצעו הזמנה (אותו לקוח שביצע מספר הזמנות יספר פעם אחת בלבד).
 

Select count(Distinct CustomerId) as "num of customers"
From Orders

שים לב כיGroup Function  מתעלמות מערכי Null כך שעלולות להתקבל תוצאות לא מדויקות אם לא נטפל במקרים אלו, לדוגמה בחישוב ממוצע.

 
שימוש ב- Group By 

כאשר משתמשים ב- Group Function ניתן לחלק את קבוצת הרשומות שעליה מבוצעת הפונקציה למספר תתי קבוצות, כך שהפונקציה תופעל על כל תת קבוצה בנפרד.
ההפרדה לתתי קבוצות מתבצעת ע"י הוספת הפסוקית Group By למשפט ה- select  בתוספת ציון העמודה על פיה תתבצע החלוקה לתתי הקבוצות.

דוגמה:
בסיס נתונים:Northwind.
הצגת שמות הערים  ומספר העובדים שגרים בכל אחת מהן על פי הנתונים שבטבלת Employees.

Select count(*) as "num of employees",city
From Employees
Group by City

התוצאה שתתקבל לאחר הרצת הקוד:
num of employees  city            
---------------        --------------- 
1                 Kirkland
4                   London
 1                Redmond
2                    Seattle
1                  Tacoma

(  5 row(s) affected)



*ניתן להגדיר תת קבוצה לתת קבוצה ע"י סימון פסיק לאחר שם העמודה וציון שם עמודה נוספת, שתהווה בסיס למיון המשני.

שים לב:
1. אין אפשרות להציג שדות נוספים שונים מ-  Group Functionלאחר המילה select , מלבד מילים המופיעות לאחר תת המשפט :Group By.
2. ב-SQL Server  אסור לבצע כינון של group function כגון:
select max(avg(unitprice))... 
(אך קיימות סביבות אחרות המאפשרות זאת).

 
שימוש ב- Having

לא ניתן להפעיל תנאי where על  ערך המוחזר כתוצאה מ-  Group Functionולכן, כאשר רוצים לסנן תשובות המוחזרות כתוצאה מהפעלתgroup Function  משתמשים בציון התנאי לאחר המילה having.

דוגמה:
בסיס הנתונים NorthWind
הצגת שמות הערים שגרים בהן לפחות שני עובדים+ ציון מספר העובדים ע"פ הנתונים מטבלת Employees.

Select count(*)"num of employee",city
From Employees
Group by City
having count(*)>=2
התוצאה שתתקבל לאחר הרצת הקוד:

city            num of employee 
--------------- --------------- 
4              London
2               Seattle

( row(s) affected2 )

דוגמה - דוגמה מסכמת:
הצגת ה-id  של כל הלקוחות שביצעו יותר מ- 5 הזמנות משנת 1998 והילך + ציון מספר ההזמנות. הנתונים המוחזרים יוצגו במיון אלפה-ביתי.
"Select customerid,count(*) as "num of order
From orders
where OrderDate>='01/01/1998'
Group by CustomerID
having count(*)>=5
order by customerid


 
תתי שאילתות

קיימים נתונים מסוימים שניתן להציגם אך ורק ע"י הפעלת תת שאילתה בתוך השאילתה הראשית. לדוגמה: הצגת שם המוצר בעל המחיר המינימלי. אנו יודעים כי שימוש ב- Group Function מאפשר להציג תוצאות של הפונקציות או שדות המופיעים לאחר משפט 
ה- group by ועל כן במקרה כמו זה, היינו רוצים להציג את פרטי המוצר שמחירו שווה למחיר המינימלי אשר יחושב בתת שאילתה.

כמה עובדות על שימוש בתת שאילתות:
•	השאילתה הראשית תקראMain Query  כאשר תתי השאילתות יקראו Sub - Query.
•	ניתן לכתוב מספר תתי שאילתות  עבור שאילתה ראשית אחת.
•	ניתן לשלב תת שאילתה אחרי: Where, Having ו-From.
•	התת שאילתה תמיד מורצת לפני השאילתה הראשית.
•	תת שאילתה תיכתב בסוגריים.
•	תת שאילתה תופיע בצד הימני של אופרטור ההשוואה.
•	אין להשתמש במשפט order by  בתת שאילתה .
•	התת שאילתה תחזיר עמודה אחת אליה תבוצע ההשוואה (בבסיסי נתונים שונים מ- SQL Server קיימת אפשרות שהתת שאילתה תחזיר יותר מעמודה אחת).
•	אם אופרטור ההשוואה בין השאילתה העיקרית לתת שאילתה הוא סימן שוויון (=) התת שאילתה חייבת להחזיר תשובה בודדת.

דוגמה:
בסיס נתונים:Northwind.
הצגת המחיר ושם המוצר בעל העלות הנמוכה ביותר מטבלת products

Select ProductName, UnitPrice
From Products
Where UnitPrice=(select min(UnitPrice)
From Products)			  	  


דוגמה :
בסיס הנתונים northwind 
ציון מספר הפריטים בהזמנה הגדולה ביותר.
(עבור כל הזמנה מחשבים מהו סה"כ מספר הפריטים שנרכשו בה ,ואז בודקים מי המקסימלית בין התוצאות שהתקבלו.)
select max(s.s_quantity) 
from( select sum(quantity) as  s_quantity 
from [order details]
group by orderId) s 
*שים לב לשימוש בתת שאילתה בתת פסוקית  from ובשימוש ב-aliases
תוצאת הרצת הקוד:
----------- 
346
 
האופרטורים In , All ו- Any
כאשר התת שאילתה תחזיר מספר ערכים נשתמש עבור ההשוואה בתוספת אחד האופרטורים הבאים:

In - נשתמש בו כאשר נרצה לבצע השוואה מול אחד מהערכים שחזרו מתת השאילתה (ההתנהגות זהה להתנהגות אופרטור  inבתת משפט where).

All - נשתמש בו כאשר נרצה שהערך הנבדק יושווה ויקיים את התנאי מול כל אחד מהערכים שיחזרו מתת השאילתה (אופרטור ההשוואה ישלב את אחד האופרטורים הבאים : >,<,=,=<,=>,<>).

Any - נשתמש בו כאשר נרצה שהערך הנבדק יושווה ויקיים את התנאי מול לפחות אחד מהערכים שיחזרו מתת השאילתה ( אופרטור ההשוואה ישלב את אחד האופרטורים הבאים : >,<,=,=<,=>,<>).

דוגמה:
בסיס נתונים NorthWind
דוגמה זו מחזירה מספרי ושמות הלקוחות  אשר הזמינו משלוח בתאריך 07/15/96.

SELECT  customerid , companyname           
FROM     customers
WHERE   customerid = ANY ( SELECT
                                                DISTINCT  customerid
                         	                 	FROM   orders
WHERE  CONVERT(CHAR(10),orderdate,101) = '07/15/1996')

תוצאת הרצת הקוד:

customerid 	companyname                              
-------------- 	------------------
WELLI      	Wellington Importadora
 
דוגמה :
בסיס הנתונים NorthWind:
דוגמה זו מחזירה את וה-id   ושמות המוצרים אשר הוזמנו מהם יותר מ-1200 פריטים.

select ProductID,ProductName  
from products where ProductID in(select ProductID
				from [order details]
				group by  ProductID
				having sum(Quantity )>1200)

התוצאה המתקבלת מהרצת הקוד:

ProductID   ProductName                              
----------- ---------------------------------------- 
59            Raclette Courdavault
56            Gnocchi di nonna Alice
60            Camembert Pierrot
31            Gorgonzola Telino

(4 row(s) affected)
שימוש באופרטור EXISTS   

אופרטור EXISTS בודק האם ערך מופיע ברשימת הערכים החוזרת מתת-שאילתה או לא.
אם הערך קיים, אופרטור EXISTS מחזיר TRUE מבלי להמשיך ולבדוק את שאר הערכים, ואם הערך אינו קיים – מחזיר FALSE.

ניתן כמובן להשתמש גם באופרטורNOT EXISTS , שיפעל בדיוק הפוך:
אם הערך קיים, אופרטור NOT EXISTS יחזיר  FALSEבעוד שאם הערך אינו קיים  יוחזרTRUE .

דוגמה:
בסיס הנתונים:NorthWind
הדוגמה מחזירה את ה-id  של כל הלקוחות הקיימים במאגר הלקוחות אך לא קיימת להם כרגע הזמנה במאגר ההזמנות.

Select customerid
From customers
Where not exists(select customerid
     From orders
     Where customerid=customers.customerid)

התוצאה שתתקבל מהרצת הקוד:

customerid 
---------- 
FISSA
PARIS

תת שאילתה שלא מחזירה רשומות
תת שאילתה שלא מחזירה רשומות תגרום לכך שגם השאילתה החיצונית לא תחזיר שום רשומה (אלא אם התנאי בשאילתה החיצונית מגדיר אחרת).

תת שאילתה המחזירה ערך  null
במידה ותת השאילתה תחזיר ערך null השאילתה החיצונית לא תחזיר שום רשומה. (יתקבל  0 row(s) affected)))
פעולות על יחסים 

ניתן לכתוב שתי שאילתות ולהפעיל ביניהן את אחת האפשרויות הבאות:
union  (איחוד)- תשובת שתי השאילתות תאוחד לתשובה אחת.
Intersect (חיתוך)- רק המשותף לשתי השאילתות יופיע בתוצאה הסופית.
Minus  (חיסור)- תוכן תוצאת שאילתה אחת יוחסר מתוכן שאילתה אחרת.

במידה ומשתמשים באחת מאפשרויות אלו לשילוב תוצאות שאילתות יש להקפיד כי מספר העמודות יהיה זהה בכל שאילתה או שיסופק ערך null במקום העמודות החסרות, כן סוגי 

 
הקשרים בין הטבלאות בבסיס הנתונים NorthWind מוצגים בדיאגרמה הבאה:  
 
הקשרים בין הטבלאות בבסיס הנתונים Pubs  מוצגים בדיאגרמה הבאה:

 
